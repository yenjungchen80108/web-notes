---
sidebar_position: 4
---

# Heap

## Heap çš„å®šç¾©

â¸»

ğŸ” ä¸€ã€ç‚ºä»€éº¼èªª MinHeap / MaxHeap åœ¨ã€ŒæŸ¥æ‰¾æœ€å¤§æˆ–æœ€å°å€¼ã€æ–¹é¢å¾ˆæ–¹ä¾¿ï¼Ÿ

âœ… Heap çš„ç‰¹æ€§ï¼š

- MinHeapï¼šæ ¹ç¯€é»æ°¸é æ˜¯æ•´å€‹æ¨¹çš„æœ€å°å€¼
- MaxHeapï¼šæ ¹ç¯€é»æ°¸é æ˜¯æ•´å€‹æ¨¹çš„æœ€å¤§å€¼

ğŸ‘‰ å› æ­¤ï¼š

- æŸ¥æ‰¾æœ€å°å€¼ï¼ˆMinHeapï¼‰ â†’ ç›´æ¥å›å‚³æ ¹ç¯€é» â†’ O(1)
- æŸ¥æ‰¾æœ€å¤§å€¼ï¼ˆMaxHeapï¼‰ â†’ ç›´æ¥å›å‚³æ ¹ç¯€é» â†’ O(1)
  Heap ä¸æ˜¯ Binary Search Treeï¼å®ƒåªä¿è­‰ã€Œçˆ¶å­ç¯€é»ä¹‹é–“çš„å¤§å°é—œä¿‚ã€ï¼Œä½†ä¸ä¿è­‰æ•´é«”æœ‰åºã€‚

```js
// MinHeap æŸ¥æ‰¾æœ€å°å€¼
const min = heap[0]; // O(1)
```

é©ç”¨å ´æ™¯ï¼š

- Top K å•é¡Œ
- å‹•æ…‹ç¶­è­·æœ€å¤§æˆ–æœ€å°å€¼
- å„ªå…ˆä½‡åˆ—ï¼ˆPriority Queueï¼‰

â¸»

ğŸŒ³ äºŒã€Heap èˆ‡ Binary Search Tree çš„ä¸»è¦å·®ç•°ï¼Ÿ

| æ¯”è¼ƒé»         | MinHeap / MaxHeap                              | Binary Search Tree (BST)                   |
| -------------- | ---------------------------------------------- | ------------------------------------------ |
| çµæ§‹è¦å‰‡       | çˆ¶ç¯€é»èˆ‡å­ç¯€é»æœ‰é †åºé—œä¿‚ï¼Œä½†å·¦å³ç„¡ç‰¹å®šå¤§å°é †åº | å·¦ < ä¸­ < å³ï¼Œæ»¿è¶³ä¸­åºéæ­·ç‚ºå‡åº           |
| æœ€å€¼æŸ¥æ‰¾       | O(1)ï¼Œå› ç‚ºæœ€å€¼åœ¨æ ¹ç¯€é»                         | O(log n) å¹³å‡ã€O(n) æœ€å·®ï¼Œéœ€èµ°åˆ°æœ€å·¦æˆ–æœ€å³ |
| æ’å…¥/åˆªé™¤      | O(log n)ï¼Œç¶­æŒå †ç©æ€§è³ª                         | O(log n) å¹³å‡ã€O(n) æœ€å·®ï¼ˆè¦–å¹³è¡¡æ€§ï¼‰       |
| å¯å¦æœå°‹ä»»æ„å€¼ | ä¸é©åˆï¼Œå› ç‚ºå·¦å³å­æ¨¹ç„¡åº â†’ O(n)                | é©åˆæœå°‹ä»»æ„å€¼ â†’ O(log n) å¹³å‡             |
| å¹³è¡¡æ€§         | å¤©ç”Ÿæ˜¯å¹³è¡¡çš„å®Œæ•´äºŒå…ƒæ¨¹                         | å¯èƒ½ä¸å¹³è¡¡ï¼ˆé™¤éæ˜¯ AVL / Red-Black Treeï¼‰  |

â¸»

ğŸ§  ç°¡å–®ç¸½çµï¼š

âœ… Heap é©åˆï¼š

- å¿«é€Ÿå–å‡ºæœ€å¤§æˆ–æœ€å°å€¼ï¼ˆO(1)ï¼‰
- ä¸é—œå¿ƒã€Œä¸­é–“æŸå€‹å€¼åœ¨å“ªè£¡ã€
- è³‡æ–™ä¸éœ€è¦æ’åºï¼Œåªéœ€è¦å‹•æ…‹è¿½è¹¤æ¥µå€¼

âœ… BST é©åˆï¼š

- æœå°‹ä»»æ„å€¼
- è³‡æ–™éœ€è¦æœ‰åºï¼ˆä¾‹å¦‚å€é–“æŸ¥è©¢ã€ç¯„åœç¯©é¸ï¼‰
- æƒ³ç”¨ä¸­åºéæ­·å–å¾—æ’åºå¾Œçš„çµæœ

â¸»

âœ¨ åœ–åƒåŒ–ç†è§£ï¼ˆä»¥ MaxHeap èˆ‡ BST ç‚ºä¾‹ï¼‰

MaxHeapï¼š

```js
     100
    /   \
  90     80
 / \     / \
70 60   50 40
```

- æŸ¥æœ€å¤§å€¼ï¼š100ï¼ˆæ ¹ï¼‰
- æŸ¥å…¶ä»–å€¼ï¼šåªèƒ½ä¸€å±¤ä¸€å±¤å¾€ä¸‹æ‰¾ â†’ O(n)

BSTï¼š

```js
      50
     /  \
   30    70
  / \    / \
20  40  60  80
```

- æŸ¥ 80ï¼šå¾æ ¹ä¸€è·¯å¾€å³èµ° â†’ O(log n)
- æŸ¥æœ€å¤§å€¼ï¼šå³å­ç¯€é»èµ°åˆ°åº•

â¸»

ğŸ§ª çµè«–ï¼š

- ä½ åªæƒ³ã€Œå¿«é€ŸçŸ¥é“èª°æ˜¯æœ€å°æˆ–æœ€å¤§ã€â†’ âœ… ç”¨ Heapï¼
- ä½ æƒ³ã€Œæ‰¾æŸå€‹å…·é«”å€¼ã€æ’åºæˆ–åšç¯„åœæŸ¥è©¢ã€â†’ âœ… ç”¨ Binary Search Treeï¼

â¸»

## Heap æ˜¯ä¸æ˜¯ã€Œåªèƒ½ã€ç”¨ä¾†æ‰¾æ¥µå€¼ï¼Ÿ

âœ… åŸºæœ¬ä¸Šæ˜¯çš„ã€‚

Heapï¼ˆå°¤å…¶æ˜¯ Priority Queueï¼‰å°±æ˜¯ç‚ºäº†ä»¥ä¸‹å¹¾ä»¶äº‹è¨­è¨ˆçš„ï¼š

- å¿«é€Ÿæ‰¾æœ€å¤§/æœ€å°å€¼ â†’ O(1)
- æ’å…¥ / ç§»é™¤æœ€å¤§/æœ€å°å€¼ â†’ O(log n)
- ä¸éœ€è¦é—œå¿ƒé †åºï¼Œåªåœ¨ä¹ã€Œèª°æœ€å¤§/æœ€å°ã€

âŒ å®ƒ ä¸æ˜¯ç‚ºäº†æŸ¥æ‰¾æŸå€‹ç‰¹å®šå€¼è¨­è¨ˆï¼Œå› ç‚ºæ•´å€‹æ¨¹é™¤äº†æ ¹ä¹‹å¤–æ˜¯ç„¡åºçš„ã€‚

â¸»

ğŸ”§ é‚£å¦‚æœæˆ‘æ—¢æƒ³æ‰¾ã€Œæœ€å¤§/æœ€å°å€¼ã€ï¼Œåˆæƒ³ã€Œå¿«é€Ÿæ‰¾ç‰¹å®šå€¼ã€æ€éº¼è¾¦ï¼Ÿ

æ˜¯ä¸æ˜¯è¦çµåˆ heap + binary search tree çš„æ¦‚å¿µï¼Ÿ

âœ… æ˜¯çš„ï¼Œæœ‰ä¸€äº›è¤‡é›œè³‡æ–™çµæ§‹å°±çœŸçš„é€™éº¼åšäº†ï¼

â¸»

ğŸ” å¸¸è¦‹çš„è§£æ³•/å»¶ä¼¸è³‡æ–™çµæ§‹ï¼š

1ï¸âƒ£ Treapï¼ˆTree + Heap çš„ hybridï¼‰

- æ˜¯ä¸€ç¨®åŒæ™‚æ»¿è¶³ BST & Heap æ€§è³ªçš„è³‡æ–™çµæ§‹ã€‚
- ç¶­è­· BST æ€§è³ªï¼šå·¦å°å³å¤§
- ç¶­è­· Heap æ€§è³ªï¼šæ¯å€‹ç¯€é»æœ‰ä¸€å€‹éš¨æ©Ÿå„ªå…ˆå€¼ï¼ˆç¶­æŒå¹³è¡¡ï¼‰
- æ’å…¥ã€åˆªé™¤éƒ½å¯åœ¨å¹³å‡ O(log n) é‹ä½œ
- ğŸ‘‰ å¯ä»¥ç”¨ä¾†å¿«é€ŸæŸ¥å€¼ï¼ŒåŒæ™‚ä¿æœ‰å¹³è¡¡ï¼ˆæ¯” AVL/Red-Black Tree å¯¦ä½œç°¡å–®ï¼‰

â¸»

2ï¸âƒ£ HashMap + Heap çµ„åˆï¼ˆå¯¦æˆ°ä¸­å¸¸è¦‹ï¼‰

- åœ¨ LeetCode æˆ–å¯¦éš›é–‹ç™¼ä¸­ï¼Œæœ‰æ™‚æœƒé€™æ¨£è¨­è¨ˆï¼š
- HashMap: è®“ä½ å¯ä»¥ O(1) æŸ¥æ‰¾ä»»æ„å€¼æ˜¯å¦å­˜åœ¨
- Heap: å¿«é€Ÿæ‰¾å‡ºæ¥µå€¼ï¼ˆæœ€å¤§æˆ–æœ€å°ï¼‰

ğŸ“¦ ç¯„ä¾‹å ´æ™¯ï¼š

- è¨˜éŒ„ç·šä¸ŠéŠæˆ²ä¸­æ‰€æœ‰ç©å®¶åˆ†æ•¸ï¼ˆæ‰¾æœ€é«˜åˆ†åˆè¦æ‰¾ç‰¹å®šç©å®¶ï¼‰
- Top-K é »ç‡å…ƒç´ ï¼ˆä½ å¯èƒ½ç”¨ HashMap çµ±è¨ˆ + Heap æ’åºï¼‰

â¸»

ğŸ§  å°çµå°æ¯”

| çµæ§‹         | æŸ¥æœ€å¤§/æœ€å° | æŸ¥ä»»æ„å€¼            | æ’å…¥        | åˆªé™¤æœ€å€¼        | å¹³è¡¡æ€§                    |
| ------------ | ----------- | ------------------- | ----------- | --------------- | ------------------------- |
| Heap         | âœ… O(1)     | âŒ O(n)             | âœ… O(log n) | âœ… O(log n)     | âœ… å®Œå…¨äºŒå…ƒæ¨¹             |
| BST          | âŒ O(log n) | âœ… O(log n)         | âœ… O(log n) | âŒ éœ€æœå°‹å¾Œåˆªé™¤ | âŒï¼ˆéœ€ AVL or Red-Blackï¼‰ |
| Treap        | âœ… O(log n) | âœ… O(log n)         | âœ… O(log n) | âœ… O(log n)     | âœ… è‡ªå‹•å¹³è¡¡               |
| HashMap+Heap | âœ… O(1)     | âœ… O(1)ï¼ˆé€é Mapï¼‰ | è¤‡åˆæ“ä½œ    | è¤‡åˆæ“ä½œ        | -                         |

## Insert æ“ä½œï¼ˆæ’å…¥æ–°ç¯€é»ï¼‰

â›“ æµç¨‹ï¼š

1. æŠŠæ–°å€¼åŠ åˆ°é™£åˆ—çš„æœ€å¾Œä¸€å€‹ä½ç½®ï¼ˆç¶­æŒå®Œå…¨äºŒå…ƒæ¨¹ï¼‰
2. å¾€ä¸Šå†’æ³¡ï¼ˆbubble up / heapify upï¼‰ï¼šèˆ‡çˆ¶ç¯€é»æ¯”è¼ƒï¼Œè‹¥ä¸ç¬¦åˆ heap æ€§è³ªå°±äº¤æ›
3. ä¸€ç›´äº¤æ›ç›´åˆ°æ»¿è¶³ heap æ¢ä»¶

ğŸ§  JavaScript MaxHeap æ’å…¥ä¾‹å­ï¼š

```js
class MaxHeap {
  constructor() {
    this.heap = [];
  }

  insert(value) {
    this.heap.push(value);
    this.bubbleUp();
  }

  bubbleUp() {
    let index = this.heap.length - 1;
    while (index > 0) {
      let parent = Math.floor((index - 1) / 2);
      if (this.heap[parent] >= this.heap[index]) break;
      [this.heap[parent], this.heap[index]] = [
        this.heap[index],
        this.heap[parent],
      ];
      index = parent;
    }
  }
}
```

## Delete æ“ä½œï¼ˆåˆªé™¤æ ¹ç¯€é»ï¼‰

â›“ æµç¨‹ï¼ˆä»¥ MaxHeap ç‚ºä¾‹ï¼‰ï¼š

1. å–å‡ºå †é ‚ this.heap[0]ï¼ˆæœ€å¤§å€¼ï¼‰
2. å°‡æœ€å¾Œä¸€å€‹å…ƒç´ ç§»åˆ°é ‚éƒ¨
3. å¾€ä¸‹æ²‰ï¼ˆbubble down / heapify downï¼‰ï¼šèˆ‡è¼ƒå¤§çš„å­ç¯€é»æ¯”è¼ƒï¼Œè‹¥é•åæ¢ä»¶å°±äº¤æ›
4. ç›´åˆ°æ¢å¾© heap å±¬æ€§

ğŸ§  JavaScript MaxHeap åˆªé™¤é ‚éƒ¨ç¯€é»ä¾‹å­ï¼š

```js
removeMax() {
  if (this.heap.length === 0) return null;
  const max = this.heap[0];
  const end = this.heap.pop();
  if (this.heap.length > 0) {
    this.heap[0] = end;
    this.bubbleDown();
  }
  return max;
}

bubbleDown() {
  let index = 0;
  const length = this.heap.length;
  const element = this.heap[0];

  while (true) {
    let left = 2 * index + 1;
    let right = 2 * index + 2;
    let swap = null;

    if (left < length && this.heap[left] > element) {
      swap = left;
    }
    if (right < length &&
        this.heap[right] > (swap === null ? element : this.heap[left])) {
      swap = right;
    }

    if (swap === null) break;

    [this.heap[index], this.heap[swap]] = [this.heap[swap], this.heap[index]];
    index = swap;
  }
}
```

## Heap Sortï¼ˆå †æ’åºï¼‰

â›“ æµç¨‹ï¼š

1. æŠŠåŸå§‹é™£åˆ—å»ºç«‹æˆ MaxHeapï¼ˆå»ºå †ï¼‰
2. æŠŠå †é ‚å…ƒç´ ï¼ˆæœ€å¤§å€¼ï¼‰èˆ‡é™£åˆ—æœ«ç«¯äº¤æ›
3. æ’é™¤æœ€å¾Œä¸€ä½å¾Œå°å‰©ä¸‹çš„é™£åˆ—åŸ·è¡Œ bubbleDownï¼ˆé‡å»º heapï¼‰
4. é‡è¤‡ç›´åˆ°æ’åºå®Œæˆ

ğŸ§  JavaScript Heap Sortï¼š

```js
function heapSort(arr) {
  const n = arr.length;

  // Build max heap
  for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
    heapify(arr, n, i);
  }

  // Extract max one by one
  for (let i = n - 1; i > 0; i--) {
    [arr[0], arr[i]] = [arr[i], arr[0]]; // swap
    heapify(arr, i, 0); // rebuild heap
  }

  return arr;
}

function heapify(arr, n, i) {
  let largest = i;
  let left = 2 * i + 1;
  let right = 2 * i + 2;

  if (left < n && arr[left] > arr[largest]) largest = left;
  if (right < n && arr[right] > arr[largest]) largest = right;

  if (largest !== i) {
    [arr[i], arr[largest]] = [arr[largest], arr[i]];
    heapify(arr, n, largest);
  }
}
```

| æ“ä½œ      | èªªæ˜                          | æ™‚é–“è¤‡é›œåº¦ |
| --------- | ----------------------------- | ---------- |
| insert    | æ’å…¥æ–°å€¼ä¸¦å¾€ä¸Šèª¿æ•´            | O(log n)   |
| delete    | ç§»é™¤æœ€å¤§æˆ–æœ€å°å€¼ä¸¦å¾€ä¸‹èª¿æ•´    | O(log n)   |
| heap sort | ä¸€æ¬¡æ’åºæ•´å€‹é™£åˆ—ï¼ˆå»ºå †+é‡å»ºï¼‰ | O(n log n) |
